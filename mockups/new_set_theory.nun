# should be unspecified but infinite
data u := Z | S u.

val a : type.

val g : a -> u.

val mem : u -> u -> prop.

# extensionality
axiom forall (A : a) (B : a). g A = g B || (exists (x : a). ~ (mem (g x) (g A) = mem (g x) (g B))).

# high-level "mem", with built-in guard
## CORRECT VERSION (but Nunchaku complains):
#rec Mem : u -> u -> prop :=
#  forall x y. Mem x y = (mem x y asserting ((exists a. g a = x) && (exists b. g b = y))).

## WRONG VERSION:
#rec Mem : u -> u -> prop :=
#  forall x y. Mem x y = mem x y.

rec Mem : u -> u -> prop :=
  forall x y. Mem x y = unique_unsafe (fun P. P = mem x y && (exists a. g a = x) && (exists b. g b = y)).

val trans_mem : a -> a -> prop.

# overapproximation of transitive closure
axiom forall x (y : a). mem (g x) (g y) => trans_mem x y.
axiom forall x y (z : a). trans_mem x y && mem (g y) (g z) => trans_mem x z.

# acyclicity
axiom forall x. ~ trans_mem x x.

# empty set
rec emptyset : u :=
  emptyset = unique_unsafe (fun A. forall a. ~ mem (g a) A && (exists a. g a = A)).

# subset
rec subset : u -> u -> prop :=
  forall A B. subset A B = (forall a. Mem (g a) A => Mem (g a) B).

# powerset
rec Pow : u -> u :=
  forall B. Pow B = unique_unsafe (fun C. forall A. Mem (g A) C = subset (g A) B).

val c : u.
val d : u.

# goal ~ subset c d.

goal Mem emptyset c.
