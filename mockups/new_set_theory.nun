# should be unspecified but infinite
data u := Z | S u.

val a : type.

val g : a -> u.

val mem_raw : u -> u -> prop.

# extensionality
axiom forall (A : a) (B : a). g A = g B || (exists (x : a). ~ (mem_raw (g x) (g A) = mem_raw (g x) (g B))).

rec mem : u -> u -> prop :=
  forall x y. mem x y = unique_unsafe (fun P. P = mem_raw x y && (exists a. g a = x) && (exists b. g b = y)).

val trans_mem : a -> a -> prop.

# overapproximation of transitive closure
axiom forall x (y : a). mem_raw (g x) (g y) => trans_mem x y.
axiom forall x y (z : a). trans_mem x y && mem_raw (g y) (g z) => trans_mem x z.

# acyclicity
axiom forall x. ~ trans_mem x x.

# empty set
rec emptyset : u :=
  emptyset = unique_unsafe (fun A. forall a. ~ mem_raw (g a) A && (exists a. g a = A)).

# subset
rec subset : u -> u -> prop :=
  forall A B. subset A B = (forall a. mem (g a) A => mem (g a) B).

# union
rec union : u -> u -> u :=
  forall A B. union A B = unique_unsafe (fun C. forall x. mem (g x) C = (mem (g x) A || mem (g x) B)).

# intersection
rec inter : u -> u -> u :=
  forall A B. inter A B = unique_unsafe (fun C. forall x. mem (g x) C = (mem (g x) A && mem (g x) B)).

# substraction
rec minus : u -> u -> u :=
  forall A B. minus A B = unique_unsafe (fun C. forall x. mem (g x) C = (mem (g x) A && ~(mem (g x) B))).

# powerset
rec Pow : u -> u :=
  forall B. Pow B = unique_unsafe (fun C. forall A. mem (g A) C = subset (g A) B).

# big union
rec Union : u -> u :=
  forall A. Union A = unique_unsafe (fun U. forall x. mem (g x) U = (exists X. mem (g x) (g X) and mem (g X) (g A))).

val v : u.
val w : u.
val x : u.
val y : u.
val z : u.

goal ~ (x = y) && ~ (y = z) && ~ (x = z) && x = union y z.

# goal x = Pow y.
