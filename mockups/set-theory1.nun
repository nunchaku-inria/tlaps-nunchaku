val u : type.

val emptyset : u.
val mem : u -> u -> prop.
val singleton : u -> u.
axiom forall x. ~ (mem x emptyset).

# ext
axiom forall x y. (x = y) = (forall z. mem z x = mem z y).

axiom forall a b. mem a (singleton b) => (a=b).
# FIXME axiom forall x. (singleton x) != emptyset.

pred trans_mem : u -> u -> prop :=
  forall x y. mem x y => trans_mem x y;
  forall x y z. mem x y && trans_mem y z => trans_mem x z.

# well-founded
axiom forall x. ~ (trans_mem x x).




 val cup : u -> u -> u.
 val cap : u -> u -> u.
# val setminus : u -> u -> u.

axiom forall x. mem x (singleton x).
axiom forall a b x. ((mem x a) && (mem x b)) => (mem x (cap a b)).
#     forall a b x. ((is_in a x) || (is_in b x)) => (is_in (cup a b) x).
#     forall a b x. ((is_in a x) && (~(is_in b x))) => (is_in (setminus a b) x).





# goals

# goal exists a b. ~ (mem a b).
# goal exists a b. mem a b.
# goal exists a. ~ mem (choice (fun x. ~ (mem x a))) a.

goal exists a b x. (mem x a)&&(~ (mem x (cap a b))).